## About Neon Cold Starts

A cold start in Neon begins when a database with a supended compute endpoint receives a connection + SQL query. Neon starts the database compute, processes the query, and serves the response.

### What is Neon?

Neon is [serverless Postgres](https://neon.tech): Standard PostgreSQL in a fully-managed cloud platform that separates storage and compute. This unlocks features like autoscaling, branching, and **scale to zero**.

### Scale to zero, defined

When a Neon compute endpoint hasn't received any connections for a specified amount of time, it will autosuspend. This makes the service **cost-efficient**: Users never pay for database compute they aren't actively using. Storage remains safe in cheap S3 object storage.

But scale to zero is only useful if the database can start quickly when needed...

### How Neon optimizes cold start speed

Neon keeps a certain amount of empty computes "pre-warmed" in compute pools to ensure that when a user's database needs to start, most of the work is done already. More technical details are available on the Neon Blog: [cold starts just got hot](https://neon.tech/blog/cold-starts-just-got-hot).

## Where to use scale-to-zero databases

Look at the cold start times documented above and decide: in what scenarios is an occasional _[AVG Cold Start Time]_ millisecond delay acceptable? The answer may depend on the specifics of your project, but here are some example scenarios where many users find scale to zero useful:

- **Non-Production Databases** - Development, preview, staging, test databases.
- **Internal Apps** - If the userbase for your app is a limited number of employees, the db is likely idle more often than active.
- **Database-per-user Architectures** - Instead of having a single database for all users, if you have a separate database for each user, the activity level of any one database may be low enough that scale to zero results in significant cost reduction.
- **Small Projects** - For small projects, configuring the production database to scale to zero can make it more cost-efficient without major impact to UX.

### How often will users hit cold starts?

That depends primarily on two factors: (1) Configured duration of inactivity required to suspend compute, and (2) Pattern of activity on the database.

[WIDGET LETTING A USER PLAY WITH DURATION VS COLD START FREQUENCY]


### How do cold starts affect usability?

For end-users, a cold start will add _[AVG Cold Start Time]_ millisecond delay to the response time of the first query to hit a suspended compute. In a web application that may result in part or all of a page taking _[AVG Cold Start Time]_ milliseconds longer to render.


## Benchmark methodology

To gather real-world cold start times, the benchmark uses a Neon project with a separate [database branch](https://neon.tech/docs/introduction/branching) for each of the above variants. A [serverless function](https://github.com/ruf-io/neon-cold-start/blob/main/setup/index.js) executes the following steps every 30 minutes:

1. Check that the database is autosuspended
2. Connect and execute a SQL query on the database, forcing it to start.
3. Log the total response time from before connection create to after response received.
4. Suspend the database.

### Benchmark Code

All code for the benchmark and display of results is available [on GitHub](https://github.com/ruf-io/neon-cold-start/blob/main/setup/index.js) Here is a snippet showing how the timing of the cold start is measured:

```javascript
// Run benchmark
const before = new Date();  // <-- Start Timer Here
const benchmarkPool = new Pool({
    host: benchmarkEndpoint.host,
    password: benchmarkRolePassword,
    user: ROLE_NAME,
    database: DATABASE_NAME,
    ssl: true,
});

await benchmarkPool.query(benchmarkQuery);
const after = new Date();  // <-- End Timer Here
const benchmarkValue = after.getTime() - before.getTime();
benchmarkPool.end();
```

### Benchmark Specifications

<dl>
    <dt>Database Compute Size:</dt>
    <dd>0.25 CU (0.25 vCPU, 1GB RAM)</dd>
    <dt>Database Region:</dt>
    <dd>AWS US-East-2 (Ohio)</dd>
    <dt>Lambda Region:</dt>
    <dd>AWS US-East-2 (Ohio)</dd>

    <dt>Postgres Version:</dt>
    <dd>PostgreSQL 16</dd>
    <dt>Postgres Driver:</dt>
    <dd><a href="https://node-postgres.com/">node-postgres</a></dd>
</dl>